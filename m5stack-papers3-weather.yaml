esphome:
  name: m5papers3-weather
  friendly_name: M5Paper Weather Display
  build_path: /config/esphome/m5papers3-weather
  platformio_options:
    build_flags: "-DBOARD_HAS_PSRAM"
  libraries:
    - EPDIY=https://github.com/Frogy76/epdiy
  # includes:
  #   - weather_icons.h  # TODO: Icons als ESPHome Image-Komponenten implementieren
  on_boot:
    priority: -100
    then:
      - rtttl.play: 'two short:d=4,o=5,b=100:16e6,16e6'
      - delay: 2s
      - component.update: weather_display
      - lambda: |-
          id(system_initialized) = true;

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  framework:
    type: esp-idf
    version: latest
    sdkconfig_options:
      CONFIG_EPD_OUTPUT_LUT_ASSEMBLY: "y"
      CONFIG_ESP32S3_INSTRUCTION_SET_AI_DSP: "y"
      CONFIG_ESP32S3_VECTOR_INSTRUCTIONS_SUPPORT: "y"

globals:
  - id: system_initialized
    type: bool
    restore_value: no
    initial_value: 'false'

psram:
  mode: octal
  speed: 80MHz

logger:
  level: INFO
  baud_rate: 0
  logs:
    wifi: WARN
    esp-idf: WARN

api:
  reboot_timeout: 6h
  services:
    - service: update_display
      then:
        - component.update: weather_display
    - service: play_tone
      variables:
        rtttl_string: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return rtttl_string;'

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 6h
  power_save_mode: LIGHT

external_components:
  - source:
      type: git
      url: https://github.com/Frogy76/esphome_components
      ref: main
    refresh: 0s

i2c:
  sda: GPIO41
  scl: GPIO42
  scan: true
  id: bus_internal
  frequency: 200kHz

# ============================================
# WEATHER SENSORS FROM HOME ASSISTANT
# ============================================
sensor:
  # OpenWeatherMap sensors
  - platform: homeassistant
    id: weather_temperature
    entity_id: sensor.openweathermap_temperature
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(system_initialized);'
            then:
              - component.update: weather_display

  - platform: homeassistant
    id: weather_humidity
    entity_id: sensor.openweathermap_humidity

  - platform: homeassistant
    id: weather_pressure
    entity_id: sensor.openweathermap_pressure

  - platform: homeassistant
    id: weather_wind_speed
    entity_id: sensor.openweathermap_wind_speed

  - platform: homeassistant
    id: weather_feels_like
    entity_id: sensor.openweathermap_feels_like_temperature

  - platform: homeassistant
    id: weather_uv_index
    entity_id: sensor.openweathermap_uv_index

  - platform: homeassistant
    id: weather_wind_gust
    entity_id: sensor.openweathermap_wind_gust

  - platform: homeassistant
    id: weather_visibility
    entity_id: sensor.openweathermap_visibility

  - platform: homeassistant
    id: weather_cloud_coverage
    entity_id: sensor.openweathermap_cloud_coverage

  # System sensors
  - platform: internal_temperature
    name: "Chip Temperature"
    id: chip_temp

  - platform: adc
    pin: GPIO3
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0

text_sensor:
  - platform: homeassistant
    id: weather_condition
    entity_id: sensor.openweathermap_condition
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(system_initialized);'
            then:
              - component.update: weather_display

  - platform: homeassistant
    id: weather_forecast_0
    entity_id: weather.openweathermap
    attribute: forecast[0].condition

  - platform: homeassistant
    id: weather_forecast_temp_0
    entity_id: weather.openweathermap
    attribute: forecast[0].temperature

binary_sensor:
  - platform: gpio
    pin:
      number: 4
      inverted: true
    name: "Charge Status"
    id: charge_status
    device_class: battery_charging

# ============================================
# TIME SYNCHRONIZATION
# ============================================
time:
  - platform: pcf8563  # RTC on M5Paper
    id: rtc_time
    address: 0x51
    update_interval: never

  - platform: homeassistant
    id: ha_time
    timezone: Europe/Berlin  # ADJUST: Your timezone
    update_interval: 1h
    on_time_sync:
      then:
        - pcf8563.write_time:
            id: rtc_time

# ============================================
# DISPLAY UPDATE INTERVALS
# ============================================
interval:
  # Full display refresh every 6 hours (anti-ghosting)
  - interval: 6h
    then:
      - logger.log: "Full display refresh"
      - component.update: weather_display

  # Status LED blink (system running)
  - interval: 30s
    then:
      - light.turn_on:
          id: status_led
          brightness: 20%
      - delay: 100ms
      - light.turn_off: status_led

# ============================================
# HARDWARE COMPONENTS
# ============================================
light:
  - platform: monochromatic
    id: status_led
    name: "Status LED"
    output: gpio_0
    restore_mode: ALWAYS_OFF
    internal: true

output:
  - platform: ledc
    id: rtttl_pin
    pin: 21
  - platform: ledc
    id: gpio_0
    pin: 0
    inverted: true

rtttl:
  output: rtttl_pin
  id: buzzer
  gain: 60%

touchscreen:
  platform: gt911
  id: touch_panel
  interrupt_pin: GPIO48
  transform:
    mirror_x: true
    mirror_y: true
  on_touch:
    - lambda: |-
        ESP_LOGI("touch", "x=%d, y=%d", touch.x, touch.y);
    - component.update: weather_display

# ============================================
# FONTS
# ============================================
font:
  # Large font for main temperature
  - file: "gfonts://Roboto@700"  # Bold
    id: font_large
    size: 120

  # Medium font for details
  - file: "gfonts://Roboto"
    id: font_medium
    size: 48

  # Small font for labels
  - file: "gfonts://Roboto"
    id: font_small
    size: 32

  # Tiny font for additional info
  - file: "gfonts://Roboto"
    id: font_tiny
    size: 24

# ============================================
# WEATHER DISPLAY
# ============================================
display:
  - platform: ed047tc1
    id: weather_display
    pwr_pin: GPIO45
    bst_en_pin: GPIO46
    xstl_pin: GPIO13
    xle_pin: GPIO15
    spv_pin: GPIO17
    ckv_pin: GPIO18
    pclk_pin: GPIO16
    d0_pin: GPIO6
    d1_pin: GPIO14
    d2_pin: GPIO7
    d3_pin: GPIO12
    d4_pin: GPIO9
    d5_pin: GPIO11
    d6_pin: GPIO8
    d7_pin: GPIO10
    update_interval: 1min  # Update every minute for current time
    rotation: 90
    lambda: |-
      // Screen dimensions (after 90째 rotation)
      #define SCREEN_W 540
      #define SCREEN_H 960

      // Colors (for E-Ink: 0x00=black, 0xFF=white)
      #define BLACK 0x00
      #define WHITE 0xFF
      #define GRAY 0x88

      // ========================================
      // WEATHER ICON SELECTION
      // ========================================
      // TODO: Define icons as ESPHome Image components
      // const uint8_t* weather_icon = nullptr;
      // uint32_t icon_width = 128;
      // uint32_t icon_height = 128;

      std::string condition = id(weather_condition).state;

      // if (condition == "sunny" || condition == "clear") {
      //   weather_icon = weather_sunny_data;
      //   icon_width = weather_sunny_width;
      //   icon_height = weather_sunny_height;
      // }
      // else if (condition == "cloudy") {
      //   weather_icon = weather_cloudy_data;
      //   icon_width = weather_cloudy_width;
      //   icon_height = weather_cloudy_height;
      // }
      // else if (condition == "partlycloudy") {
      //   weather_icon = weather_partlycloudy_data;
      //   icon_width = weather_partlycloudy_width;
      //   icon_height = weather_partlycloudy_height;
      // }
      // else if (condition == "rainy" || condition == "rain") {
      //   weather_icon = weather_rainy_data;
      //   icon_width = weather_rainy_width;
      //   icon_height = weather_rainy_height;
      // }
      // else if (condition == "pouring") {
      //   weather_icon = weather_pouring_data;
      //   icon_width = weather_pouring_width;
      //   icon_height = weather_pouring_height;
      // }
      // else if (condition == "snowy" || condition == "snow") {
      //   weather_icon = weather_snowy_data;
      //   icon_width = weather_snowy_width;
      //   icon_height = weather_snowy_height;
      // }
      // else if (condition == "fog" || condition == "foggy") {
      //   weather_icon = weather_fog_data;
      //   icon_width = weather_fog_width;
      //   icon_height = weather_fog_height;
      // }
      // else if (condition == "lightning" || condition == "lightning-rainy") {
      //   weather_icon = weather_lightning_data;
      //   icon_width = weather_lightning_width;
      //   icon_height = weather_lightning_height;
      // }

      // ========================================
      // HEADER: DATE & TIME
      // ========================================
      it.strftime(SCREEN_W/2, 30, id(font_small), TextAlign::TOP_CENTER,
                  "%A, %d. %B %Y", id(rtc_time).now());

      it.strftime(SCREEN_W/2, 85, id(font_large), TextAlign::TOP_CENTER,
                  "%H:%M", id(rtc_time).now());

      // Separator line
      it.line(40, 220, SCREEN_W-40, 220);

      // ========================================
      // MAIN SECTION: TEMPERATURE & ICON
      // ========================================

      // Weather icon (left) - TODO: Icons must be defined as ESPHome Image components
      // Raw data cannot be used directly with it.image()
      // if (weather_icon != nullptr) {
      //   it.image(60, 260, weather_icon, icon_width, icon_height);
      // }

      // Main temperature (right of icon)
      if (id(weather_temperature).has_state()) {
        it.printf(340, 290, id(font_large), TextAlign::CENTER,
                  "%.1f째", id(weather_temperature).state);
        it.printf(340, 400, id(font_medium), TextAlign::CENTER, "C");
      }

      // Weather condition as text
      it.printf(SCREEN_W/2, 470, id(font_medium), TextAlign::TOP_CENTER,
                "%s", condition.c_str());

      // ========================================
      // DETAILS SECTION (3 columns)
      // ========================================
      int details_y = 570;
      int col_spacing = SCREEN_W / 3;

      // Column 1: Humidity
      it.printf(col_spacing/2, details_y, id(font_small), TextAlign::TOP_CENTER,
                "Humidity");
      if (id(weather_humidity).has_state()) {
        it.printf(col_spacing/2, details_y+40, id(font_medium), TextAlign::TOP_CENTER,
                  "%.0f%%", id(weather_humidity).state);
      }

      // Column 2: Feels like temperature
      it.printf(SCREEN_W/2, details_y, id(font_small), TextAlign::TOP_CENTER,
                "Feels like");
      if (id(weather_feels_like).has_state()) {
        it.printf(SCREEN_W/2, details_y+40, id(font_medium), TextAlign::TOP_CENTER,
                  "%.1f째C", id(weather_feels_like).state);
      }

      // Column 3: Pressure
      it.printf(SCREEN_W-col_spacing/2, details_y, id(font_small), TextAlign::TOP_CENTER,
                "Pressure");
      if (id(weather_pressure).has_state()) {
        it.printf(SCREEN_W-col_spacing/2, details_y+40, id(font_medium), TextAlign::TOP_CENTER,
                  "%.0f", id(weather_pressure).state);
        it.printf(SCREEN_W-col_spacing/2, details_y+90, id(font_small), TextAlign::TOP_CENTER,
                  "hPa");
      }

      // ========================================
      // ADDITIONAL INFO: Wind & UV Index
      // ========================================
      int extra_y = 730;

      // Wind
      if (id(weather_wind_speed).has_state()) {
        it.printf(SCREEN_W/3, extra_y, id(font_small), TextAlign::TOP_CENTER,
                  "Wind: %.1f km/h", id(weather_wind_speed).state);
      }

      // UV-Index
      if (id(weather_uv_index).has_state()) {
        it.printf(2*SCREEN_W/3, extra_y, id(font_small), TextAlign::TOP_CENTER,
                  "UV: %.1f", id(weather_uv_index).state);
      }

      // Cloudiness
      if (id(weather_cloud_coverage).has_state()) {
        it.printf(SCREEN_W/2, extra_y+40, id(font_small), TextAlign::TOP_CENTER,
                  "Cloudiness: %.0f%%", id(weather_cloud_coverage).state);
      }

      // ========================================
      // FOOTER: BATTERY & STATUS
      // ========================================
      int footer_y = SCREEN_H - 60;

      // Battery voltage
      if (id(battery_voltage).has_state()) {
        float battery_v = id(battery_voltage).state;
        bool charging = id(charge_status).state;

        it.printf(40, footer_y, id(font_tiny), TextAlign::BOTTOM_LEFT,
                  "%s %.2fV",
                  charging ? "Charging" : "Battery",
                  battery_v);

        // Battery percentage (rough estimate for LiPo)
        float percent = (battery_v - 3.3) / (4.2 - 3.3) * 100.0;
        percent = max(0.0f, min(100.0f, percent));
        it.printf(40, footer_y+30, id(font_tiny), TextAlign::BOTTOM_LEFT,
                  "%.0f%%", percent);
      }

      // WiFi status
      it.printf(SCREEN_W/2, footer_y, id(font_tiny), TextAlign::BOTTOM_CENTER,
                "WiFi: Connected");

      // Last update
      it.strftime(SCREEN_W-40, footer_y, id(font_tiny), TextAlign::BOTTOM_RIGHT,
                  "Updated: %H:%M", id(rtc_time).now());

      // Chip temperature
      if (id(chip_temp).has_state()) {
        it.printf(SCREEN_W-40, footer_y+30, id(font_tiny), TextAlign::BOTTOM_RIGHT,
                  "CPU: %.1f째C", id(chip_temp).state);
      }

