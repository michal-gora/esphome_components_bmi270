esphome:
  name: m5papers3-weather
  friendly_name: M5Paper Weather Display
  build_path: /config/esphome/m5papers3-weather
  platformio_options:
    build_flags: "-DBOARD_HAS_PSRAM"
  libraries:
    - EPDIY=https://github.com/Frogy76/epdiy
  includes:
    - weather_icons.h  # Generated weather icons
  on_boot:
    priority: -100
    then:
      - rtttl.play: 'two short:d=4,o=5,b=100:16e6,16e6'
      - delay: 2s
      - component.update: weather_display
      - lambda: |-
          id(system_initialized) = true;

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  framework:
    type: esp-idf
    version: latest
    sdkconfig_options:
      CONFIG_EPD_OUTPUT_LUT_ASSEMBLY: "y"
      CONFIG_ESP32S3_INSTRUCTION_SET_AI_DSP: "y"
      CONFIG_ESP32S3_VECTOR_INSTRUCTIONS_SUPPORT: "y"

globals:
  - id: system_initialized
    type: bool
    restore_value: no
    initial_value: 'false'

psram:
  mode: octal
  speed: 80MHz

logger:
  level: INFO
  baud_rate: 0
  logs:
    wifi: WARN
    esp-idf: WARN

api:
  reboot_timeout: 6h
  services:
    - service: update_display
      then:
        - component.update: weather_display
    - service: play_tone
      variables:
        rtttl_string: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return rtttl_string;'

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 6h
  power_save_mode: LIGHT

external_components:
  - source:
      type: git
      url: https://github.com/Frogy76/esphome_components
      ref: main
    refresh: 0s

i2c:
  sda: GPIO41
  scl: GPIO42
  scan: true
  id: bus_internal
  frequency: 200kHz

# ============================================
# WETTER-SENSOREN VON HOME ASSISTANT
# ============================================
sensor:
  # OpenWeatherMap Sensoren
  - platform: homeassistant
    id: weather_temperature
    entity_id: sensor.openweathermap_temperature
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(system_initialized);'
            then:
              - component.update: weather_display

  - platform: homeassistant
    id: weather_humidity
    entity_id: sensor.openweathermap_humidity

  - platform: homeassistant
    id: weather_pressure
    entity_id: sensor.openweathermap_pressure

  - platform: homeassistant
    id: weather_wind_speed
    entity_id: sensor.openweathermap_wind_speed

  - platform: homeassistant
    id: weather_feels_like
    entity_id: sensor.openweathermap_feels_like_temperature

  - platform: homeassistant
    id: weather_uv_index
    entity_id: sensor.openweathermap_uv_index

  - platform: homeassistant
    id: weather_wind_gust
    entity_id: sensor.openweathermap_wind_gust

  - platform: homeassistant
    id: weather_visibility
    entity_id: sensor.openweathermap_visibility

  - platform: homeassistant
    id: weather_cloud_coverage
    entity_id: sensor.openweathermap_cloud_coverage

  # System-Sensoren
  - platform: internal_temperature
    name: "Chip Temperature"
    id: chip_temp

  - platform: adc
    pin: GPIO3
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0

text_sensor:
  - platform: homeassistant
    id: weather_condition
    entity_id: sensor.openweathermap_condition
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(system_initialized);'
            then:
              - component.update: weather_display

  - platform: homeassistant
    id: weather_forecast_0
    entity_id: weather.openweathermap
    attribute: forecast[0].condition

  - platform: homeassistant
    id: weather_forecast_temp_0
    entity_id: weather.openweathermap
    attribute: forecast[0].temperature

binary_sensor:
  - platform: gpio
    pin:
      number: 4
      inverted: true
    name: "Charge Status"
    id: charge_status
    device_class: battery_charging

# ============================================
# ZEIT-SYNCHRONISATION
# ============================================
time:
  - platform: pcf8563  # RTC auf dem M5Paper
    id: rtc_time
    address: 0x51
    update_interval: never

  - platform: homeassistant
    id: ha_time
    timezone: Europe/Berlin  # ANPASSEN: Deine Zeitzone
    update_interval: 1h
    on_time_sync:
      then:
        - pcf8563.write_time:
            id: rtc_time

# ============================================
# DISPLAY-UPDATE INTERVALLE
# ============================================
interval:
  # Vollständiges Display-Refresh alle 6 Stunden (gegen Ghosting)
  - interval: 6h
    then:
      - logger.log: "Full display refresh"
      - component.update: weather_display

  # Status-LED Blinken (System läuft)
  - interval: 30s
    then:
      - light.turn_on:
          id: status_led
          brightness: 20%
      - delay: 100ms
      - light.turn_off: status_led

# ============================================
# HARDWARE-KOMPONENTEN
# ============================================
light:
  - platform: monochromatic
    id: status_led
    name: "Status LED"
    output: gpio_0
    restore_mode: ALWAYS_OFF
    internal: true

output:
  - platform: ledc
    id: rtttl_pin
    pin: 21
  - platform: ledc
    id: gpio_0
    pin: 0
    inverted: true

rtttl:
  output: rtttl_pin
  id: buzzer
  gain: 60%

touchscreen:
  platform: gt911
  id: touchscreen
  interrupt_pin: GPIO48
  transform:
    mirror_x: true
    mirror_y: true
  on_touch:
    - lambda: |-
        ESP_LOGI("touch", "x=%d, y=%d", touch.x, touch.y);
    - component.update: weather_display

# ============================================
# SCHRIFTARTEN
# ============================================
font:
  # Große Schrift für Haupttemperatur
  - file: "gfonts://Roboto@700"  # Bold
    id: font_large
    size: 120

  # Mittlere Schrift für Details
  - file: "gfonts://Roboto"
    id: font_medium
    size: 48

  # Kleine Schrift für Labels
  - file: "gfonts://Roboto"
    id: font_small
    size: 32

  # Sehr kleine Schrift für Zusatzinfos
  - file: "gfonts://Roboto"
    id: font_tiny
    size: 24

# ============================================
# WETTER-DISPLAY
# ============================================
display:
  - platform: ed047tc1
    id: weather_display
    pwr_pin: GPIO45
    bst_en_pin: GPIO46
    xstl_pin: GPIO13
    xle_pin: GPIO15
    spv_pin: GPIO17
    ckv_pin: GPIO18
    pclk_pin: GPIO16
    d0_pin: GPIO6
    d1_pin: GPIO14
    d2_pin: GPIO7
    d3_pin: GPIO12
    d4_pin: GPIO9
    d5_pin: GPIO11
    d6_pin: GPIO8
    d7_pin: GPIO10
    update_interval: never
    rotation: 90
    lambda: |-
      // Bildschirm-Dimensionen (nach 90° Rotation)
      #define SCREEN_W 540
      #define SCREEN_H 960

      // Farben (für E-Ink: 0x00=schwarz, 0xFF=weiß)
      #define BLACK 0x00
      #define WHITE 0xFF
      #define GRAY 0x88

      // ========================================
      // WETTER-ICON AUSWAHL
      // ========================================
      const uint8_t* weather_icon = nullptr;
      uint32_t icon_width = 128;
      uint32_t icon_height = 128;

      std::string condition = id(weather_condition).state;

      if (condition == "sunny" || condition == "clear") {
        weather_icon = weather_sunny_data;
        icon_width = weather_sunny_width;
        icon_height = weather_sunny_height;
      }
      else if (condition == "cloudy") {
        weather_icon = weather_cloudy_data;
        icon_width = weather_cloudy_width;
        icon_height = weather_cloudy_height;
      }
      else if (condition == "partlycloudy") {
        weather_icon = weather_partlycloudy_data;
        icon_width = weather_partlycloudy_width;
        icon_height = weather_partlycloudy_height;
      }
      else if (condition == "rainy" || condition == "rain") {
        weather_icon = weather_rainy_data;
        icon_width = weather_rainy_width;
        icon_height = weather_rainy_height;
      }
      else if (condition == "pouring") {
        weather_icon = weather_pouring_data;
        icon_width = weather_pouring_width;
        icon_height = weather_pouring_height;
      }
      else if (condition == "snowy" || condition == "snow") {
        weather_icon = weather_snowy_data;
        icon_width = weather_snowy_width;
        icon_height = weather_snowy_height;
      }
      else if (condition == "fog" || condition == "foggy") {
        weather_icon = weather_fog_data;
        icon_width = weather_fog_width;
        icon_height = weather_fog_height;
      }
      else if (condition == "lightning" || condition == "lightning-rainy") {
        weather_icon = weather_lightning_data;
        icon_width = weather_lightning_width;
        icon_height = weather_lightning_height;
      }

      // ========================================
      // KOPFZEILE: DATUM & ZEIT
      // ========================================
      it.strftime(SCREEN_W/2, 30, id(font_medium), TextAlign::TOP_CENTER,
                  "%A, %d. %B %Y", id(rtc_time).now());

      it.strftime(SCREEN_W/2, 85, id(font_large), TextAlign::TOP_CENTER,
                  "%H:%M", id(rtc_time).now());

      // Trennlinie
      it.line(40, 220, SCREEN_W-40, 220);

      // ========================================
      // HAUPTBEREICH: TEMPERATUR & ICON
      // ========================================

      // Wetter-Icon (links)
      if (weather_icon != nullptr) {
        it.image(60, 260, id(weather_icon));
      }

      // Haupttemperatur (rechts vom Icon)
      if (id(weather_temperature).has_state()) {
        it.printf(340, 290, id(font_large), TextAlign::CENTER,
                  "%.1f°", id(weather_temperature).state);
        it.printf(340, 400, id(font_medium), TextAlign::CENTER, "C");
      }

      // Wetterzustand als Text
      it.printf(SCREEN_W/2, 470, id(font_medium), TextAlign::TOP_CENTER,
                "%s", condition.c_str());

      // ========================================
      // DETAILS-BEREICH (3 Spalten)
      // ========================================
      int details_y = 570;
      int col_spacing = SCREEN_W / 3;

      // Spalte 1: Luftfeuchtigkeit
      it.printf(col_spacing/2, details_y, id(font_small), TextAlign::TOP_CENTER,
                "Feuchtigkeit");
      if (id(weather_humidity).has_state()) {
        it.printf(col_spacing/2, details_y+40, id(font_medium), TextAlign::TOP_CENTER,
                  "%.0f%%", id(weather_humidity).state);
      }

      // Spalte 2: Gefühlte Temperatur
      it.printf(SCREEN_W/2, details_y, id(font_small), TextAlign::TOP_CENTER,
                "Gefühlt");
      if (id(weather_feels_like).has_state()) {
        it.printf(SCREEN_W/2, details_y+40, id(font_medium), TextAlign::TOP_CENTER,
                  "%.1f°C", id(weather_feels_like).state);
      }

      // Spalte 3: Luftdruck
      it.printf(SCREEN_W-col_spacing/2, details_y, id(font_small), TextAlign::TOP_CENTER,
                "Luftdruck");
      if (id(weather_pressure).has_state()) {
        it.printf(SCREEN_W-col_spacing/2, details_y+40, id(font_medium), TextAlign::TOP_CENTER,
                  "%.0f", id(weather_pressure).state);
        it.printf(SCREEN_W-col_spacing/2, details_y+90, id(font_small), TextAlign::TOP_CENTER,
                  "hPa");
      }

      // ========================================
      // ZUSATZ-INFO: Wind & UV-Index
      // ========================================
      int extra_y = 730;

      // Wind
      if (id(weather_wind_speed).has_state()) {
        it.printf(SCREEN_W/3, extra_y, id(font_small), TextAlign::TOP_CENTER,
                  "Wind: %.1f km/h", id(weather_wind_speed).state);
      }

      // UV-Index
      if (id(weather_uv_index).has_state()) {
        it.printf(2*SCREEN_W/3, extra_y, id(font_small), TextAlign::TOP_CENTER,
                  "UV: %.1f", id(weather_uv_index).state);
      }

      // Bewölkung
      if (id(weather_cloud_coverage).has_state()) {
        it.printf(SCREEN_W/2, extra_y+40, id(font_small), TextAlign::TOP_CENTER,
                  "Bewölkung: %.0f%%", id(weather_cloud_coverage).state);
      }

      // ========================================
      // FUSSZEILE: BATTERIE & STATUS
      // ========================================
      int footer_y = SCREEN_H - 60;

      // Batteriespannung
      if (id(battery_voltage).has_state()) {
        float battery_v = id(battery_voltage).state;
        bool charging = id(charge_status).state;

        it.printf(40, footer_y, id(font_tiny), TextAlign::BOTTOM_LEFT,
                  "%s %.2fV",
                  charging ? "Laden" : "Batterie",
                  battery_v);

        // Batterie-Prozent (grobe Schätzung für LiPo)
        float percent = (battery_v - 3.3) / (4.2 - 3.3) * 100.0;
        percent = max(0.0f, min(100.0f, percent));
        it.printf(40, footer_y+30, id(font_tiny), TextAlign::BOTTOM_LEFT,
                  "%.0f%%", percent);
      }

      // WiFi-Status
      it.printf(SCREEN_W/2, footer_y, id(font_tiny), TextAlign::BOTTOM_CENTER,
                "WiFi: %s",
                id(wifi_id).is_connected() ? "Verbunden" : "Getrennt");

      // Letzte Aktualisierung
      it.strftime(SCREEN_W-40, footer_y, id(font_tiny), TextAlign::BOTTOM_RIGHT,
                  "Update: %H:%M", id(rtc_time).now());

      // Chip-Temperatur
      if (id(chip_temp).has_state()) {
        it.printf(SCREEN_W-40, footer_y+30, id(font_tiny), TextAlign::BOTTOM_RIGHT,
                  "CPU: %.1f°C", id(chip_temp).state);
      }

